<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Clean Code on Ulises Hernández</title><link>http://blog.uliseshernandez.com/tags/clean-code/</link><description>Recent content in Clean Code on Ulises Hernández</description><generator>Hugo</generator><language>en-us</language><lastBuildDate>Mon, 11 Aug 2025 14:30:27 +0000</lastBuildDate><atom:link href="http://blog.uliseshernandez.com/tags/clean-code/index.xml" rel="self" type="application/rss+xml"/><item><title>FastAPI + Injector: A simplified approach to dependency injection in Python</title><link>http://blog.uliseshernandez.com/writings/python-dependency-injection/</link><pubDate>Mon, 11 Aug 2025 14:30:27 +0000</pubDate><guid>http://blog.uliseshernandez.com/writings/python-dependency-injection/</guid><description>&lt;p>Python is a &lt;strong>dynamically&lt;/strong> typed language, which means type checking happens at runtime—unlike statically typed languages like C# or Java. This flexibility enables powerful features such as monkey patching, hot swapping, and dynamic class creation. Because of this, &lt;strong>dependency injection&lt;/strong> (&lt;strong>DI&lt;/strong>) is not strictly required in Python applications.&lt;/p>
&lt;p>However, DI brings a formal structure to your codebase, especially when using architectural patterns like &lt;strong>Domain-Driven Design&lt;/strong> (&lt;strong>DDD&lt;/strong>) or &lt;strong>Hexagonal Architecture&lt;/strong>. It promotes flexibility by allowing large parts of the code to be replaced or modified without impacting the rest of the system. It also reduces coupling, making the system less dependent on specific implementations. This, in turn, simplifies testing, as modules can be easily mocked.&lt;/p></description></item></channel></rss>